%
% Taesoo Kim
%
% title: Lisp 이해하기
%
% abstract: 이맥스를 확장하고 이해하기 위한 Lisp의 문법(Form),
% abstract: 이를 계산(Evaluate)하는과정,
% abstract: 기본적인 데이터구조, 리스트(List)에 대해 알아본다.
%

이번 장에서는 이맥스를 확장하고 이해하는데 반드시 필요한 기본적인 Lisp의 특성들에
대해 알아본다. 이맥스 Lisp의 개발환경(Inferior Emacs Lisp)을 시작으로,
문법(Form), 리스트(List)와 계산(Evaluate)의 개념들을 하나씩 이해해보자.  이번장
마지막에는 기본적인 개념들을 바탕으로, Lisp이 어떻게 "코드를 데이터처럼" 다룰 수
있는지 이해해보도록한다.

# Lisp 개발환경

1장에서 \*scratch\* 버퍼에서 표현식(expression)을 계산(evaluate)하는 방법을
알아보았다. 이맥스에서 다양한 방법으로 표현식(expression)을 계산(evaluate)할 수
있는데, 이번절에서 버퍼를 이동하지 않고 표현식 계산하는 방법, IELM 모드에서
표현식을 계산하는법을 알아본다.

## 스크래치 버퍼

우리가 이미 알고 있는 방법으로 \*scratch\* 버퍼에서 표현식 끝에서 \k{C-j}을
입력하면 표현식을 계산해 볼 수 있다.

![\n{img} \*scratch\* 버퍼에서 계산(evaluate)하기](\s{snap -s 80x10 -o eval-in-scratch.png -c 
 C-x b "\"*sc\"" TAB RET "\"(message \\\"hello world\\\")\"" C-j})

## 미니 버퍼

두번째 방법은 버퍼를 변경하지 않고 현재 버퍼의 환경안에서 표현식을 계산하는
방법으로 \k{M-:}를 입력하면 미니버퍼에서 표현식을 계산해볼 수 있다.

![\n{img} 미니 버퍼에서 표현식 계산(evaluate)하기](\s{snap -s 80x10 
 -o eval-in-screen.png -c M-: "\"(message \\\"hello world\\\")\""})

## IELM 모드

IELM(__I__nferior __E__macs __L__isp __M__ode)는 상호적(interactive)으로 표현식을
계산하는 방법으로, 스크립트형 언어들에서 제공하는
REPL(__R__ead-__E__val-__P__rint __L__oop)과 같은 환경이다. \k{M-x ielm}을
입력하면 아래와 같은 화면이 보이는데, 현재 프롬프트에서 표현식을 입력하면
다음라인에서 표현식을 계산하고 그 결과값을 출력해 준다.

![\n{img} IELM 모드에서 표현식 계산하기](\s{snap -s 80x10 
 -o eval-in-ielm.png -c M-x \"ielm\" RET
 "\"(message \\\"hello world\\\")\"" C-j})

독자들은 제시된 방법들중 간편한 방법으로 앞으로 나오는 표현식을 자유롭게 계산해
보면 된다.

# Lisp의 문법 (Form)

Lisp 프로그램은 표현식(expression)들로 이루어진다. 가장 간단한 형태의 표현식은
아톰(atom)이라고 불리는데, 정수과 문자열 등이 이에 해당한다. 정수와 문자열은
계산(evaluate)했을 때 입력한 그대로의 값을 같는다.

![\n{img} 정수와 문자열 계산하기](\s{snap -s 80x10 
 -o eval-atoms-in-ielm.png -c M-x \"ielm\" RET
 \"123\" C-j
 "\"\\\"hello world\\\"\"" C-j})

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ {.cl}
ELISP> 123
123
ELISP> "hello world"
"hello world"
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

재미있는 형태의 표현식은 우리가 앞서 살펴본 괄호안에 여러개의 표현식을 담고 있는
형태로 앞으로 리스트(List)라고 부른다.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ {.cl}
ELISP> (message "hello world")
"hello world"
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

리스트가 계산될때에는 각각의 표현식들(element)이 좌에서 우로 계산이 되며, 첫번째
표현식의 값(value)이 함수 정의로 나머지 인자들은 함수 인자로 함수를
계산하게된다. 또한 호출된 함수가 리턴하는 결과 값을 그 표현식의 값(value)이라고
부른다.

첫인자(element)를 함수로 나머지(element)를 함수의 인자(argument)로 표현하는
리스트 형태(form)가 Lisp의 문법의 전부이다. (이러한 규칙의 예외들을 특수
형태(special form)라고 부르는데, 이들에 대해서는 다음장에서 자세히 알아본다.)
이렇게 간단한 형태의 문법은 다양한 장점을 가지고 있는데, 대표적인 장점인 메타
프로그래밍(Meta Programming)에 대해서는 이번장에서 이해를 해보도록하자.

# 표현식 계산하기 (Evaluate)

% expression

% atom: string/integer
% list(umm first list?) -> (func arg1 arg2 ...)

정수와 문자열은 입력한 그대로를 값으로 가진다(evaluate to itself).

리스트 형태의 수식이 어떻게 계산되는지(evaluate), '(messagebox "hello
world")'를 예로 사용해서 알아보자.

 1. 리스트 형태의 수식이 입력되면, 리스프 인터프리터는 리스트의 첫 번째
원소를 이름으로 하는 함수 정의를 찾는다. 우리 예에서는 messagebox라는 이
름을 가진 함수의 정의를 찾는다.
 2. 함수 정의를 찾으면, 리스트의 나머지 인자들을 왼쪽에서 오른쪽으로 계
산한다(call-by-value). "hello world"의 경우 자기 자신으로 계산된다. 만약
인자가 또다시 리스트라면 똑같은 규칙을 적용하여 재귀적으로 계산한다.
 3. 앞에서 찾은 함수 정의에 인자를 적용하여 함수의 결과값을 계산한다.
messagebox는 *Messages*에 넘겨받은 인자를 출력하고, 그 출력된 문자열을
함수의 결과값으로 리턴한다.

이것이 Lisp의 가장 많이 쓰이고 가장 기본적인 계산 규칙(evaluation
rule)이다.

그런데, 필요에 의해 이 규칙을 따르지 않도록 정해진 몇 가지 특수한 연산자
들이 있다. special operator와 매크로가 그에 해당한다. 이에 대해서는 차후
에 설명한다. (special operator는 if 등장할 때 설명하면 될 듯.)

# 심볼 (Symbol)

Lisp에서 message 심볼은 쓰이는 위치에 따라 함수나 값을 의미함을 알았다. 그러면
어떻게 함수나 값이 아니라 "심볼 그 자체"를 나타낼 수 있을까? 자 \*scratch\*
버퍼로 이동 후 아래와 같은 표현식을 해석해본다. (message 문자열 끝에서 \k{C-j}를
입력한다.)

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ {.cl}
message
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

우리가 살펴보았던 "message 변수가 정의 되지 않았다"는 에러메시지를 볼 수
있다. 그러면 **'**message를 입력후 (작은 따옴표 '가 앞에 붙었다.) 해석 해본다.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ {.cl}
'message
message
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

작은 따옴표가 의미하는바가 무엇일까? 첫째. 'message는 해석하면 message 함수나 값
대신 message 심볼을 리턴한다. 둘째. 당장 표현식을 해석 하는 대신 표현식을
수정하거나? 해석하는 시점을 필요한 때로 미룰수 있게 되었다. (앞으로 자세히 알아볼
것이다.)

작은 따옴표(quote)는 심볼 이외에 표현식 앞에 붙일 수 도 있는데, 표현식(리스트)의
각각의 요소에 모두 작은 따옴표를 적용하라는 의미이다.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ {.cl}
'(a b c)                                ; quote in front of list
(a b c)

(list 'a 'b 'c)                         ; equivalent
(a b c)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

즉 message 표현식 앞에 작은 따옴표를 붙여 message 함수를 호출 하는 대신 "해석하면
message 함수를 호출하는 표현식이 리턴되는 표현식"을 표현할 수 있게 되었다.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ {.cl}
'(message "hello world")
(message "hello world")
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# 리스트 (List)

Lisp의 이름, __LIS__t __P__rocessing이 의미 하듯, Lisp은 리스트로 구성된 표현식을
계산하는 언어다. 다시 말해 리스트는 Lisp의 가장 가장 근본을 이루는 데이터구조로,
Lisp을 제대로 이해하기 위해서는 반드시 이해하고 넘어가야하는 개념이다. 이번장에서
어떻게 리스트를 만들고 사용하는지 차근 차근 알아보도록 한다.

먼저 리스트를 만들기위해 필요한 함수 \f{cons} (__cons__tructor)를 살펴
보자. \f{cons} 함수는 \f{car} (__a__dd__r__ess)과 \f{cdr} (__d__ecrement)로
지칭되는 두개의 인자를 받고, 두 인자를 묶어 하나의 cons 구조를 리턴한다.

    cons is a built-in function in `C source code'.

    (cons CAR CDR)

    Create a new cons, give it CAR and CDR as components, and return it.

다음의 표현식을 계산해보자.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ {.cl}
ELISP> (cons 1 2)
(1 . 2)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

위의 cons 구조는 일반적으로 아래와 같이 도표화 하여 나타낼 수 있다.

               +---> 2 (cdr)
      cons     |
         +---+-|-+
         | o | o |
         +-|-+---+
           |
           +---> 1 (car)

좌/우를 하나의 cons 구조라고 칭하며, 각각의 박스는 해당하는 값(value)을 가리키게
된다. 또한 묶어진 (cons)의 값(value) 1과 2는 car과 cdr의 함수로 접근할 수
있다. car함수는 cons 구조를 인자로 받아 첫번째 값 1을 리턴하며, cdr함수는
cons구조를 인자를 받아 두번째 값 2를 리턴한다.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ {.cl}
(car (cons 1 2))
1
(cdr (cons 1 2))
2
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

조금더 복잡하게 cons 구조를 생성해 보자.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ {.cl}
(cons 1 (cons 2 (cons 3 4)))
(1 2 3 . 4)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

위와 같은 cons 구조는 다음과 같은 다이어그램으로 나타낼 수 있다.

      cons          cons          cons
         +---+---+     +---+---+     +---+---+
         | o | o------>| o | o------>| o | o------> 4
         +-|-+---+     +-|-+---+     +-|-+---+
           |             |             |
           +---> 1       +---> 2       +---> 3

위의 cons 구조는 Lisp의 모든 데이터구조의 기본이 되며, cons의 오른쪽 박스가 다른
cons 구조를 가리키게되면서 여러개의 cons를 묶을 수 있게 된다. 리스트 또한 cons의
구조를 활용하여 표현할 수 있는데, 리스트의 끝을 나타내기 위해 nil (null 또는
ground 라고도 불림)을 마지막 element로 넣어 리스트를 표현한다.

즉 (cons 1 nil)은 1을 하나의 원소로 갖는 리스트이며, "(1)" 이라고 표현되고 아래와
같은 도표로 나타낸다.

      cons                                 
         +---+---+     
         | o | o------> nil
         +-|-+---+     
           |           
           +---> 1     

또한 1,2,3을 요소로 갖는 리스트는 아래와 같이 표현할 수 있다. 즉 리스트를
구성하는 하나의 cons 구조의 왼쪽 박스는 값을 가리키고, 오른쪽 박스는 다음 cons
구조를 가리키게 된다. 다음 cons 구조가 없는 리스트의 마지막 cons구조는 nil을
가리키게 되며, 리스트의 마지막을 명시적으로 표시하게 된다.

      cons          cons          cons
         +---+---+     +---+---+     +---+---+
         | o | o------>| o | o------>| o | o------> nil
         +-|-+---+     +-|-+---+     +-|-+---+
           |             |             |
           +---> 1       +---> 2       +---> 3

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ {.cl}
(cons 1 (cons 2 (cons 3 nil)))
(1 2 3)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

그러면 비어 있는 (0개의 element를 갖는) 리스트는 어떻게 표현 할까?

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ {.cl}
()                                      ; empty list
nil                                     ; nil == (), ground or nil/null
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

비어 있는 리스트는 () 또는 동일하게 (특별히) nil 심볼로 나타낸다. 자 그럼 하나의
원소를 갖는 리스트는 아래와 같이 만들 수 있다.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ {.cl}
(cons 1 ())                             ; one element
(1)                                     ; 1 -> nil
(cons 1 nil)                            ; equally
(1)                                     ; 1 -> nil
(cons 1 (cons 2 nil))                   ; two elements
(1 2)                                   ; 1 -> 2 -> nil
(cons 1 (cons 2 (cons 3 nil)))          ; three elements
(1 2 3)                                 ; 1 -> 2 -> 3 -> nil
(list 1 2 3)                            ; three elements
(1 2 3)                                 ; 1 -> 2 -> 3 -> nil
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

물론 \f{list} 함수를 이용하면 더욱 간단하게 리스트를 만들 수 있다. 위의 예제 처럼
여러개의 cons를 사용하는것 대신에 "(list 1 2 3)"를 이용해 동일한 리스트 구조를
만들 수 있다.

# 메타 프로그래밍 (Meta Programming)

앞에서 설명한것과 같이 Lisp은 __LIS__t __P__rocessing의 줄임말이다. 즉 Lisp은
리스트를 하나 하나 해석하는 언어다. 이번 절에서 앞서서 언급한 "표현식은 심볼들의
리스트다"라는 말을 이해해보려고 한다. 먼저 리스트가 어떻게 출력되는지 살펴보자. 

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ {.cl}
(list 1 2 3)                            ; three elements
(1 2 3)                                 ; 1 -> 2 -> 3 -> nil
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

"(1 2 3)"의 형태(form)이 우리가 사용했던 표현식과 유사한가?

    +---- 리스트의 시작
    v
    (message "width: %d" fill-column)
       원소1      원소2      원소3    ^
                      리스트의 끝 ----+

표현식은 리스트의 형태를 띄고 있고, 첫번째 원소가 함수로 나머지는 인자로
해석된다. 아래와 같이 각각의 표현식을 해석해 보자. 

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ {.cl}
(message "width %d" fill-column)         ; form
"width 80"

'(message "width %d" fill-column)        ; 'form
(message "width %d" fill-column)

(eval '(message "width %d" fill-column)) ; evaluate 'form
"width 80"
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

첫번째 표현식은 우리가 앞으로 만들어갈 표현식이다. 두번째 표현식을 첫번째
표현식을 작은 따옴표(quote)로 심볼화하고 해석했고, 첫번째 표현식이
리턴되었다. 세번째 표현식은 두번째 표현식을 \f{eval: 표현식 해석} 함수를 통해
해석 한 것으로 첫번째 표현식과 동일한 결과가 리턴되었다.

우리가 이번장에서 배운 모든 지식을 바탕으로 표현식(리스트)을 만들어 보자.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ {.cl}
(cons 'message nil)
(message)

(cons 'message 
      (cons '"width %d" 
            (cons 'fill-column nil)))
(message "width %d" fill-column)

(list 'message '"width %d" 'fill-column)
(message "width %d" fill-column)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

첫번째 표현식에서 'message 심볼하나만 갖는 리스트를 만들었고, 두번째 표현식에서
\f{cons} 함수를 이용해 앞으로 해석할 표현식(리스트)를 만들었다. 마지막 표현식에서
간편한 \f{list} 함수를 이용해 동일한 기능의 표현식을 만들어 보았다.

우리가 하려고 하는 일은 "message 함수를 이용한 출력"이었다. 하지만 위의 과정은
"message 함수를 이용한 출력"을 하기위해 코드를 생성하는 일이 되었다. 흔히들
이러한 작업을 메타 프로그래밍이라고 부른다. 더 나아가 domain specific 언어를
디자인 한다라고 말한다. Lisp에서 이 두가지의 개념을 가능하게 했던 근간을 살펴보면
프로그래머가 표현하는 코드가 파싱해야 하는 문자열이 아니라, 리스트 데이터 였다는
사실이다. 코드가 리스트라는 구조있는 데이터로 표현됨으로써 코드(리스트 데이터)를
프로그래머가 쉽게 수정이 가능했다.

아래의 표현식들을 살펴보자.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ {.cl}
(cons 'message '("width %d" fill-column))
(message "width %d" fill-column)

(eval (cons 'message '("width %d" fill-column)))
"width 80"

(eval (cons 'message-box '("width %d" fill-column)))
"width 80"
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

위의 코드는 \f{message} 함수 대신 \f{message-box} 함수를 동일한 인자로 호출 하는
과정을 보여준다. 리스트인 코드를 수정해 message 함수 대신 message-box 함수를 호출
가능하게 되었다.

사람들은 왜 php, javascript와 python의 eval() 함수를 피해야할 패턴으로 분류하면서
Lisp의 이러한 특성들을 동경?하는 것일까? 한가지 Lisp이 다른 언어와 다른점은
코드를 구조화된 데이터로 관리 할 수있다는 점인데, javascript와 python에서
eval()을 사용하기 위해서는 코드를 구조가 없는 문자열로 변환 후 전달해야 하기
때문이다. 즉 다른 언어의 eval()은 코드 문자열을 생성하는 과정에서의 외부의
작은변화가 문자열의 전체의미를 변화시킬 수 있기때문에 항상 프로그래머의 의도대로
동작하지 않을 수 있기 때문이다. 간단하게 말하면 구조화 된 코드를 구조가 없는
문자열로 변환시키고 조작한후 다시 코드로 변환하는 과정은 쉽게 오류를 범할 수 있을
뿐 아니라, 이해하기도 힘든 코드가 되기 때문이다.

# 정리

이번장에서 Lisp에서 리스트, 심볼, 해석의 개념을 알아보았다. 다음장에서는 이를
기반으로 이맥스의 테트리스 코드를 읽어 보려고 한다. \k{M-x tetris}를 실행해
볼까?


<!-- XXXXXXXXXXXXXXXXX -->
# 두가지 의미의 심볼 (Symbol)

다음 표현식을 살펴보자.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ {.cl}
(message "hello world")
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

위 표현식은 message 함수를 "hello world" 문자열을 인자로 evaluate 하라는
의미이다. 여기서 **message**는 화면 하단에 문자열을 출력하는 함수의
**이름**이다. 즉 message는 함수정의를 **지칭하는** 용도로 사용되고 있다. 뻔한?
소리를 이렇게 강조하는 이유는 Lisp에서는 명시적으로 이름(앞으로 **심볼**)과
함수정의 (또는 변수 값)을 분리해서 쓴다. 그렇게 함으로써 언어 특성이 간단해 지고
코드를 데이터처럼? 사용할 수 있게 된다. (앞으로 살펴 볼 것이다.)

Lisp 인터프리터가 위의 표현식을 해석하는 과정을 상상해보자. 먼저 문자열로 주어진
표현식을 받은후, 파싱을 하고, message 심볼에 바인딩(bound)된 함수정의를 찾아서
주어진 인자와 함께 evaluate 하게 될것이다. 만약 message 함수에 바인드된
함수정의를 찾지 못하면 어떻게 될까?

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ {.cl}
(no-such-a-func "hello world")
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

위의 표현식을 evaluate하면 아래와 같은 에러가 발생한다.

    Debugger entered--Lisp error: (void-function no-such-a-func)
      (no-such-a-func "hello world")
      eval((no-such-a-func "hello world"))
      ....

이맥스는 에러가 발생하면 기본적으로 위와 같은 디버깅 정보를 출력한다. 에러
메시지는 아래에서 위로 (콜 스택처럼) 인터프리터가 evaluate하는 과정을
나타낸다. 즉, 위의 메시지는 주어진 표현식을 evaluate하는 과정에서
no-such-a-func에 바인드된 함수를 찾지 못함(void-function)을 의미한다.

다시 한번 아래와 같은 표현식을 evaluate해보자.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ {.cl}
(message no-such-a-var)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

그러면 다음과 같은 에러가 발생하는데,

    Debugger entered--Lisp error: (void-variable no-such-a-var)
      (message no-such-a-var)
      eval((message no-such-a-var))
      ...

다양한 언어에 노출된 우리에게는 당연하게 생각될 수도 있는 간단한 개념이지만, 위의
에러메시지를 통해서 함수에 이름을 할당하듯, 값에도 이름을 할당할 수 있음을 알게
되었다. 위의 에러메시지를 다시 살펴보면, 우리가 주어진 표현식을 evaluate 하는
과정에서 no-such-a-var 심볼에 해당하는 값을 찾을 수 없음을 의미한다.

이 간단한 실험들은 몇가지 중요한 Lisp의 특성들을 알려주는데, 아래의 두 라인의
코드를 비교해서 생각해 보자.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ {.cl}
(message no-such-a-var)
(message "hello world")
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

1. "hello world": 값 (value)
1. no-such-a-var: 변수(variable)를 지칭하는 심볼
1. message: 함수(function)를 지칭하는 심볼
1. no-such-a-var의 심볼이 evaluate 된후 message 함수가 호출 (call-by-value)

즉, message와 no-such-a-var과 같은 심볼(이름)을 사용할때는 "이름"자체를
사용한다는 의미가 아니라 이름에 해당되는 값, 함수로 대체된 후 evaluate 됨을
기억하자. 그러면 아래의 표현식은 어떠한 에러가 날까?

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ {.cl}
(message message)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

앞선 실험에서 message라는 심볼(이름)은 화면에 출력하는 함수에 바인딩되어 있음을
알아보았다. 위의 표현식은 message 함수를 message 인자로 부르는 것일까?

    Debugger entered--Lisp error: (void-variable message)
      (message message)
      eval((message message))
      ...

신기하게도 첫 message 심볼은 함수로, 두번째 message 심볼은 값(변수)으로 evaluate
하려고 하는것을 볼수있다. 이번 실험을 통해서 알려주고 싶었던 중요한 개념은 Lisp은
심볼의 **위치**에 따라 심볼을 함수로 볼지, 변수로 볼지 결정한다는 것이다. 즉, 표현식의
가장 앞서 나오는 message 라는 심볼은 함수로 여겨지고, 그 이외의 위치에 나타나면
변수로 여겨진다.

사실 이제껏 "표현식"이라고 지칭했던 것은 Lisp의 코드를 "리스트"의 형태로 나타낸
것이다. 필자가 이절을 통해서 말하고 싶은것은 세가지다.

1. 심볼은 함수 또는 값을 가리킨다.
2. 심볼을 어떻게 해석할지는 사용된 위치에 따라 결정된다.
3. 표현식은 심볼들의 리스트다.
